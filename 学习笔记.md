# 《Vue3 + vite + Ts + pinia + 实战 + 源码 + electron》学习笔记

## 视频地址

https://www.bilibili.com/video/BV1dS4y1y7vd?spm_id_from=333.788.videopod.episodes&vd_source=b703c80d84797dc2894c957d982ca073&p=7

## Ref全家桶

#### ref & isRef & shallowRef & triggerRef & customRef

ref 用于创建响应式数据， isRef 用于检测变量是否为ref对象， shallowRef 则创建浅层响应式数据（只对.value的赋值响应，不深度追踪内部属性变化），

triggerRef  手动触发ref对象的响应更新，customRef - 自定义ref

补充说明：

1. ref - 将普通值转换为响应式引用对象，通过.value访问
2. isRef - 检查值是否是ref对象，返回布尔值
3. shallowRef - 创建仅对.value赋值响应的ref，不深度追踪内部属性（如您代码中注释所示，直接修改person2.value.name不会触发视图更新）
4. 注意：ref和shallowRef不能一起使用，会影响shallowRef的响应更新
5. ref获取dom元素时，需要使用泛型指定dom元素的类型，否则会报错

#### 代码

```js
const person = ref({
	name:'fk'
})
console.log(isRef(person));
const person2=shallowRef({
	name:'kf'
})
const changeFun = () => {
    //person2.value.name= 'kff';
    //直接修改person2.value.name不会触发视图更新
    //ref和shallowRef是不能一起写，会影响shallowRef 造成视图的更新
    //person.value.name = 'fkf';
    person2.value= {
        name:'kff'
    };
}

const changeFun2 = () => {
    person2.value.name= 'kff';
    triggerRef(person2);
    //手动触发ref对象的响应更新
}

// customRef 自定义ref
// 1. 接收一个工厂函数，工厂函数接收两个参数 track 和 trigge
// 2. track 函数用于追踪响应式数据的变化，trigger 函数用于触发响应式数据的更新
// 3. 返回一个对象，该对象必须包含 get 和 set 方法
// 4. get 方法用于获取响应式数据的值，set 方法用于设置响应式数据的值
// 5. 当响应式数据的值发生变化时，会自动调用 trigger 函数触发响应式数据的更新
const myRef = <T>(value: T) => {
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
      }
    }
  })
}
const person3 = myRef({ name: 'fkf' });
console.log(person3.value);

//可以使用ref获取dom元素，但是需要使用泛型指定dom元素的类型，否则会报错
<div ref="refDom"></div>
const refDom = ref<HTMLElement | null>(null);
console.log(refDom);
```



### 